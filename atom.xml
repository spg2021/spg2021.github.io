<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>spg2021&#39;s blog</title>
  
  <subtitle>愿能屠龙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://spg2021.github.io/"/>
  <updated>2020-04-04T16:21:02.646Z</updated>
  <id>https://spg2021.github.io/</id>
  
  <author>
    <name>spg2021</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2009年408数据结构程序设计题</title>
    <link href="https://spg2021.github.io/2020/03/31/408-2009/"/>
    <id>https://spg2021.github.io/2020/03/31/408-2009/</id>
    <published>2020-03-30T16:25:37.000Z</published>
    <updated>2020-04-04T16:21:02.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>（15分）已知一个带有表头结点的单链表，结点结构为：<br><img src="/img/pages/408-2009-1.png" width = "12%" height = "12%" /><br>假设该链表只给出了头指针<code>list</code>。在不改变链表的前提下，请设计一个尽可能高效的算法：<br>查找链表中倒数第  k 个位置上的结点(k 为正整数)。<br>若查找成功，算法输出该结点的 <code>data</code> 域的值，并返回 1；否则，只返回 0。<br>要求：<br>⑴ 描述算法的基本设计思想；<br>⑵ 描述算法的详细实现步骤；<br>⑶ 根据设计思想和实现步骤，采用程序设计语言描述算法</p><p><strong>注意题目所给信息</strong><br>1.带头结点<br>2.单链表：不能访问前继节点，只能访问后继节点。<br>3.未知单链表长度<br>4.k为正整数，即k&gt;0。不需要做k&lt;=0越界判断。</p><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p><strong>单链表</strong>（单向链表）数据结构回顾：<br>单链表是线性表的链式存储。由多个节点组成，每个节点又由数据域和指针域构成。如图：<br><img src="/img/pages/408-2009-4.png" width = "80%" height = "90%"/></p><a id="more"></a><h2 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h2><p>用一个结构体描述节点类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> data;  <span class="comment">//节点的数据域，用来存放数值内容 </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">link</span>;</span>  <span class="comment">// 节点的指针域，用来指向下一个节点 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的节点结构内容和题目所给的一致。</p><h2 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h2><p>关于头节点一些需要的注意的，做出如下总结梳理<br><strong>说明：</strong><br>1.头节点不是链表第一个节点，而是头节点随后紧邻的后继节点。<br>2.头节点是非必须的，可以不设置。<br>3.在计算链表长度时，头节点不计入总数。<br>4.头节点的数据域没有意义。</p><p><strong>好处：</strong><br>1.使链表首个位置的插入删除更加方便，和其他位置一样，不需要涉及到头指针的移动。<br>2.统一空表和非空表的操作处理。当非空时头指针指向的是首个节点的地址，即<code>*ListNode</code>类型，而对空表处理的时候却是<code>NULL</code>，因此造成空表和非空表操作不一致。</p><h2 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a>头指针</h2><p>其实指向某个节点的地址的指针丢失，也会造成这个节点无法访问。特别是头指针，一旦丢失，导致链表最前面的节点（头节点或者是第一个节点）无法访问，从而导致整个链表无法访问，出现内存泄漏等问题。<br><strong>作用：</strong>具有标识作用，故常用头指针冠以链表的名字</p><h2 id="单链表基本操作"><a href="#单链表基本操作" class="headerlink" title="单链表基本操作"></a>单链表基本操作</h2><p>链表的基本操作如下：</p><h3 id="链表的初始化"><a href="#链表的初始化" class="headerlink" title="链表的初始化"></a>链表的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单链表的初始化</span></span><br><span class="line"><span class="comment">返回一个ListNode指针类型变量，即链表的头指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">initLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">head</span>;</span>  <span class="comment">//定义头节点</span></span><br><span class="line">  head = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));  <span class="comment">//头结点空间申请</span></span><br><span class="line">  <span class="comment">//这里做一个判断，判断头节点是否申请成功</span></span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"内存不足！申请内存空间失败\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  head-&gt;link = <span class="literal">NULL</span>;  <span class="comment">//头节点指向的下一个节点位置置为空</span></span><br><span class="line">  <span class="keyword">return</span> head;  <span class="comment">//返回头节点地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点的创建"><a href="#节点的创建" class="headerlink" title="节点的创建"></a>节点的创建</h3><p>将创建新节点这个过程封装到一个函数，便于复用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">新创建节点</span></span><br><span class="line"><span class="comment">返回值：新节点地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> data, struct ListNode *link)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newNode</span>;</span>  <span class="comment">//定义新节点</span></span><br><span class="line">  newNode = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));  <span class="comment">//新结点空间申请</span></span><br><span class="line">  newNode-&gt;data = data;  <span class="comment">//新结点数据域初始化</span></span><br><span class="line">  newNode-&gt;link = link;  <span class="comment">//新结点指针域初始化</span></span><br><span class="line">  <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h3><p>思路：<br>调用findNodeByIndex函数(查找节点操作)，获得第 i-1 节点，然后再进行插入操作。</p><p>具体的原理实现如下图所示：<br><img src="/img/pages/408-2009-2.png" /></p><p>说明：<br>这里一个数值，以及新节点所在位置来实现单链表中新节点插入操作。<br>新节点创建在函数内进行，并不是通过真正意义上传入一个节点类型实现插入操作。<br>时间性能：O(n)</p><p>具体步骤：</p><ol><li>首先需要找到插入位置的前一个节点, 也就是图上节点<code>preNode</code>。若找不到，则是越界等问题，返回报错信息。</li><li>然后需要创建新的节点<code>newNode</code>。</li><li>插入操作实际上就是把<code>preNode</code>的后继节点改为新节点<code>newNode</code>，然后再把新节点<code>newNode</code>的后继节点改为第 <strong>i</strong>节点。需要注意<strong>顺序</strong>，以防出现<strong>断链</strong>。改动指针操作顺序正如图所示，先①后②。<br>代码如下：<br>①：<code>newNode-&gt;link = preNode-&gt;link;</code><br>②：<code>preNode-&gt;link = newNode;</code><br>对于①表示把新节点<code>newNode</code>的后继节点改为第 <strong>i</strong>节点。第 <strong>i</strong>节点的地址通过它的前继节点来寻找，即：<code>preNode-&gt;link</code><br>对于②表示把<code>preNode</code>的后继节点改为新节点<code>newNode</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">插入节点操作</span></span><br><span class="line"><span class="comment">list*：新节点插入所在的链表</span></span><br><span class="line"><span class="comment">index：新节点插入的位置</span></span><br><span class="line"><span class="comment">data：新节点数据域的值</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">0：插入失败</span></span><br><span class="line"><span class="comment">1：插入成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNodeByIndex</span><span class="params">(struct ListNode *<span class="built_in">list</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  判断说明：</span></span><br><span class="line"><span class="comment">  这里需要注意边界问题，当传入参数index=1时，</span></span><br><span class="line"><span class="comment">  也就是带头单链表插入的位置是第1个节点的位置，既然知道了位置</span></span><br><span class="line"><span class="comment">  下面无需调用findNodeByIndex函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(index == <span class="number">1</span> || <span class="built_in">list</span>-&gt;link == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;link = newNode(data, <span class="built_in">list</span>-&gt;link);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">preNode</span>;</span>  <span class="comment">//定义插入节点的前一个节点</span></span><br><span class="line">  preNode = findNodeByIndex(<span class="built_in">list</span>, index - <span class="number">1</span>);  <span class="comment">//查找前一个节点是否存在</span></span><br><span class="line">  <span class="keyword">if</span>(preNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入失败, 位置越界！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  preNode-&gt;link = newNode(data, preNode-&gt;link);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h3><p>原理如图：<br><img src="/img/pages/408-2009-3.png" width = "50%" height = "100%" /><br>思路：<br>调用find方法(查找节点操作)，获得第 i-1 节点，然后再让 i-1 位置节点的指针域指向 i 位置节点后继节点。<br>时间性能：O(n)<br>注意：先修改指针再释放节点，避免断链。<br>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过位置删除节点操作</span></span><br><span class="line"><span class="comment">list*：需要删除节点所在的链表</span></span><br><span class="line"><span class="comment">index：需要删除节点的位置</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">0：删除失败</span></span><br><span class="line"><span class="comment">1：删除成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteNodeByIndex</span><span class="params">(struct ListNode *<span class="built_in">list</span>, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">preNode</span>;</span>  <span class="comment">//需要删除节点的前一个节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">deleteNode</span>;</span>  <span class="comment">//需要删除的节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  判断说明：</span></span><br><span class="line"><span class="comment">  这里需要注意边界问题，当传入参数index=1时，</span></span><br><span class="line"><span class="comment">  也就是删除单链表第一个节点，此次就要注意index-1&lt;=0,</span></span><br><span class="line"><span class="comment">  下面调用findNodeByIndex()函数会提示越界异常错误, 得到空指针。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(index == <span class="number">1</span>)&#123;</span><br><span class="line">    preNode = <span class="built_in">list</span>;</span><br><span class="line">    deleteNode = <span class="built_in">list</span>-&gt;link;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    preNode = findNodeByIndex(<span class="built_in">list</span>, index - <span class="number">1</span>);  <span class="comment">//查找前一个节点是否存在</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数 index &lt; 1 的时候，下面调用findNodeByIndex()函数会提示越界异常错误, 得到空指针。</span></span><br><span class="line"><span class="comment">    此时index - 1 作为参数依然小于1, 调用findNodeByIndex()函数会提示越界异常错误, 得到空指针。</span></span><br><span class="line"><span class="comment">    如果参数大于链表长度，例如链表长度为3，而index传入参数的值为4的时候，显然会越界，但是index-1=3，</span></span><br><span class="line"><span class="comment">    链表确实有第3个节点，因此加上判断条件preNode-&gt;link==NULL就可以实现越界判读。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(preNode == <span class="literal">NULL</span> || preNode-&gt;link==<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"删除失败, 位置越界！\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deleteNode = preNode-&gt;link;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  printf("preNode：%d\n", preNode);</span></span><br><span class="line"><span class="comment">  printf("deleteNode：%d", deleteNode);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  preNode-&gt;link = preNode-&gt;link-&gt;link;</span><br><span class="line">  <span class="built_in">free</span>(deleteNode);  <span class="comment">//释放要删除结点的内存空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点的修改"><a href="#节点的修改" class="headerlink" title="节点的修改"></a>节点的修改</h3><p>思路：<br>调用find方法(查找节点操作)，然后再进行修改操作。<br>时间性能O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过节点位置来修改节点数据域操作</span></span><br><span class="line"><span class="comment">list*：需要修改节点所在的链表</span></span><br><span class="line"><span class="comment">index：需要修改节点的位置</span></span><br><span class="line"><span class="comment">data：需要修改节点数据域的值</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">0：修改失败</span></span><br><span class="line"><span class="comment">1：修改成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateNodeByIndex</span><span class="params">(struct ListNode *<span class="built_in">list</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">updateNode</span>;</span></span><br><span class="line">  updateNode = findNodeByIndex(<span class="built_in">list</span>, index); <span class="comment">//查找需要修改的节点是否存在</span></span><br><span class="line">  <span class="keyword">if</span>(updateNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改失败, 位置越界！\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  updateNode-&gt;data = data;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点的查找"><a href="#节点的查找" class="headerlink" title="节点的查找"></a>节点的查找</h3><p>思路：<br>插入前需要进行合法性判断，例如插入位置是 -1 或者是超过表长时，显然不合法。<br>位置合法以后，因为单链表中每个节点的查找都通过它的前继节点来访问，因此进行逐一遍历查找。<br>时间性能：O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据给定位置来查找链表中该位置的节点</span></span><br><span class="line"><span class="comment">list*：需要查找节点的所在链表</span></span><br><span class="line"><span class="comment">index：需要查找节点的位置</span></span><br><span class="line"><span class="comment">返回值：该位置节点的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">findNodeByIndex</span><span class="params">(struct ListNode *<span class="built_in">list</span>, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="comment">//检查位置合法性</span></span><br><span class="line">  <span class="keyword">if</span>(index &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"节点位置异常, 不能为负数\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> len = getLinkLength(<span class="built_in">list</span>);</span><br><span class="line">  <span class="keyword">if</span>(index &gt; len)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"节点位置异常, 位置超出表长\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>;</span></span><br><span class="line">  p = <span class="built_in">list</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i != index)&#123;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求链表长度"><a href="#求链表长度" class="headerlink" title="求链表长度"></a>求链表长度</h3><p>思路：<br>设置一个计数器，然后逐一遍历节点，每经过一个节点计数器+1。<br>时间性能：O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">求带头结点的单链表的表长</span></span><br><span class="line"><span class="comment">返回值：单链表的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLinkLength</span><span class="params">(struct ListNode *<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>;</span></span><br><span class="line">  p = <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;link != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印单链表"><a href="#打印单链表" class="headerlink" title="打印单链表"></a>打印单链表</h3><p>打印链表信息，输出每个节点地址，指向的下一个节点，内容以及表长。<br>时间性能：O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfLink</span><span class="params">(struct ListNode *<span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;  <span class="comment">//表长计数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>;</span></span><br><span class="line">  p = <span class="built_in">list</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"头节点地址：%d\n"</span>, p);</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;link != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">    len++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第%d个节点地址：%d\t数据域内容：%d\t指针域指向地址：%d\n"</span>, len, p, p-&gt;data, p-&gt;link);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"链表长度：%d\n"</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码的一些说明："><a href="#代码的一些说明：" class="headerlink" title="代码的一些说明："></a>代码的一些说明：</h3><ol><li>代码为了易于初学者掌握，并没有使用<code>typedef</code>别名定义来简化一些复杂的类型声明。想要代码更简洁，可以去尝试一下。</li><li>调用<code>malloc()</code>函数勿忘记头文件加上<code>#include&lt;stdlib.h&gt;</code>。</li><li>测试代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义头指针，指针变量名表示链表名称</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">linkList</span>;</span></span><br><span class="line">  <span class="comment">//linkList的初始化</span></span><br><span class="line">  linkList = initLinkList();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入第1个元素，位置1</span></span><br><span class="line">  addNodeByIndex(linkList, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//插入第2个元素，位置1</span></span><br><span class="line">  addNodeByIndex(linkList, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//插入第3个元素，位置1</span></span><br><span class="line">  addNodeByIndex(linkList, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  printfLink(linkList);  <span class="comment">//输出操作结果</span></span><br><span class="line">  <span class="comment">//插入第4个元素，位置99</span></span><br><span class="line">  addNodeByIndex(linkList, <span class="number">99</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除位置2的元素</span></span><br><span class="line">  deleteNodeByIndex(linkList, <span class="number">2</span>);</span><br><span class="line">  printfLink(linkList);  <span class="comment">//输出操作结果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新位置1的元素数据域为666，</span></span><br><span class="line">  updateNodeByIndex(linkList, <span class="number">1</span> ,<span class="number">666</span>);</span><br><span class="line">  printfLink(linkList);  <span class="comment">//输出操作结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于单链表的插入，删除，修改，查找都是通过位置来实现的。这四种操作还可以通过数据域进行值查找。等有时间了再补全。</li><li>关于下标从0开始的问题，本程序默认第一个节点下标是1，便于理解！！如果想写成从0开始，可以直接让index参数整体-1以及边界判断条件也做小修改，整体思路不变。</li></ol><h1 id="题目求解"><a href="#题目求解" class="headerlink" title="题目求解"></a>题目求解</h1><p>前面回顾了单链表的一些基本知识，下面来求解本题。</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><p>蛮力法，硬算。通过多次遍历单链表，一定能求解出问题，但是时间性能得不到保障。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>1.求表长len。<br>2.倒数第k个数，实际上就是：len-k+1，下标为len-k+1-1=len-k。<br>自己做个简短分析：<br>长度为5，倒数第5个，实际上就是第5-5+1=1个，下标为0。<br>长度为5，倒数第3个，实际上就是第5-3+1=3个，下标为2。<br>长度为5，倒数第2个，实际上就是第5-2+1=4个，下标为3。<br>长度为5，倒数第1个，实际上就是第5-1+1=5个，下标为4。<br>不难得出上面式子。<br>合法性判断也比较简单：倒数的数绝对超不出len的长度，如果k&gt;len，直接返回0<br>3. 然后再进行遍历单链表，到达第len-n+1节点。输出data，返回1。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1</span><span class="params">(struct ListNode *<span class="built_in">list</span>, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">list</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//遍历单链表求表长</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;link != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//合法性判断</span></span><br><span class="line">  <span class="keyword">if</span>(k &gt; len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = len - k + <span class="number">1</span>;  <span class="comment">//拿到倒数第k的实际位置i</span></span><br><span class="line">  p = <span class="built_in">list</span>;  <span class="comment">//重新初始p指针指向头节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//遍历i次，得到第i个节点</span></span><br><span class="line">  <span class="keyword">for</span>(i; i &gt; <span class="number">0</span>;i--)</span><br><span class="line">    p =p-&gt;data;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;data);  <span class="comment">//输出倒数第k节点data值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h2><p>最优解法，一次遍历完成查询。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>1.使用双指针：定义两个指针<code>*p</code>，<code>*q</code>。<br>2.<code>*q</code>指向单链表第一个节点不动，<code>*p</code>向后遍历k个节点。<br>合法性判断也比较简单：在两个指针间隔达不到k时，<code>*p</code>提前移动到尾结点处，则返回0<br>3.两个指针同时移动，直到<code>*p</code>移动到尾结点处。则<code>*q</code>指向的节点则是题目所求。</p><p>画了个图：<br><img src="/img/pages/2009-408-5.png" width = "88%" height = "88% " /><br>举了个例子，求倒数第2个节点的data值，最后q所指向的第3个节点是题目所求。</p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find2</span><span class="params">(struct ListNode *<span class="built_in">list</span>, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化双指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">list</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">q</span> = <span class="title">list</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = k;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//p指针向前遍历k次</span></span><br><span class="line">  <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//合法性判断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//两个指针一起移动，直到p指针移动至表尾</span></span><br><span class="line">  <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    q = q-&gt;link;</span><br><span class="line">    p = p-&gt;link;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, q-&gt;data);  <span class="comment">//输出倒数第k节点data值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /> <br /> <blockquote><p><strong>本文作者：</strong> spg2021<br><strong>本文链接：</strong> <a href="https://spg2021.github.io/2020/03/31/408-2009/">https://spg2021.github.io/2020/03/31/408-2009/</a><br><strong>版权声明：</strong>文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank" rel="noopener">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;（15分）已知一个带有表头结点的单链表，结点结构为：&lt;br&gt;&lt;img src=&quot;/img/pages/408-2009-1.png&quot; width = &quot;12%&quot; height = &quot;12%&quot; /&gt;&lt;br&gt;假设该链表只给出了头指针&lt;code&gt;list&lt;/code&gt;。在不改变链表的前提下，请设计一个尽可能高效的算法：&lt;br&gt;查找链表中倒数第  k 个位置上的结点(k 为正整数)。&lt;br&gt;若查找成功，算法输出该结点的 &lt;code&gt;data&lt;/code&gt; 域的值，并返回 1；否则，只返回 0。&lt;br&gt;要求：&lt;br&gt;⑴ 描述算法的基本设计思想；&lt;br&gt;⑵ 描述算法的详细实现步骤；&lt;br&gt;⑶ 根据设计思想和实现步骤，采用程序设计语言描述算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意题目所给信息&lt;/strong&gt;&lt;br&gt;1.带头结点&lt;br&gt;2.单链表：不能访问前继节点，只能访问后继节点。&lt;br&gt;3.未知单链表长度&lt;br&gt;4.k为正整数，即k&amp;gt;0。不需要做k&amp;lt;=0越界判断。&lt;/p&gt;
&lt;h1 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;单链表&lt;/strong&gt;（单向链表）数据结构回顾：&lt;br&gt;单链表是线性表的链式存储。由多个节点组成，每个节点又由数据域和指针域构成。如图：&lt;br&gt;&lt;img src=&quot;/img/pages/408-2009-4.png&quot; width = &quot;80%&quot; height = &quot;90%&quot;/&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="考研" scheme="https://spg2021.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="408" scheme="https://spg2021.github.io/tags/408/"/>
    
      <category term="数据结构" scheme="https://spg2021.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://spg2021.github.io/2020/03/01/first/"/>
    <id>https://spg2021.github.io/2020/03/01/first/</id>
    <published>2020-03-01T09:20:20.000Z</published>
    <updated>2020-04-04T10:55:49.401Z</updated>
    
    <content type="html"><![CDATA[<p>博客主要记录一些考研做题经历、程序设计以及各种技术和非技术的相关内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客主要记录一些考研做题经历、程序设计以及各种技术和非技术的相关内容。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="杂记" scheme="https://spg2021.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
